# Why Something Rather Than Nothing

## The Argument

1. Consistency — A is A — cannot be derived without presupposing itself. It is not an axiom. It is a boundary condition. Any challenge to it uses it.

2. Identity, distinction, evaluation, and logic are not a hierarchy. They are consistency at different configurations of accumulated state.

3. The observer is a region of consistency within the thing it observes. Thought and reality are not separate domains. The apparent gap between "thought requires consistency" and "reality requires consistency" presupposes a dualism the framework rejects. "Reality without consistency" is the same pattern as "nothing exists" — expressible, not executable.

4. True and false are evaluation outputs — exit conditions of a process — not symbols in a set. Evaluation has exactly two verdicts when it returns a verdict at all. Non-termination is not a third verdict. It is a non-return.

5. An expression is non-executable if evaluating it requires presupposing a condition that the expression itself denies, where that condition is necessary for evaluation to occur. It parses. It does not resolve.

6. "Nothing exists," "this statement is false," and {P, ¬P} are three instances of one pattern: expressible, not executable.

7. "Why is there something rather than nothing?" presupposes nothing is a possible state. Nothing is not a possible state. It is an operation that cannot complete because completing it requires removing the structure performing the removal.

8. The question is not unanswered. It is a string the universe can contain but cannot run.

## The Question

"Why is there something rather than nothing?" presupposes that nothing is a possible state. It isn't.

This paper uses "possible" in the strongest sense: a candidate as a coherent alternative state without presupposing the machinery it negates. The argument is not about satisfiability within a theory. It is about what it takes for "alternative state" to be a coherent phrase.

"Nothing exists" is not false. It is expressible but not executable. The string can be written. The operation it describes — the removal of all structure including the structure required to perform the removal — does not terminate. Any attempt to evaluate it imports an evaluation context — structure, distinction, process — which is exactly what "absolute nothing" denies. The assertion does not fail a test. It cannot enter the testing procedure without already violating what it asserts.

"Expressible but not executable" is used throughout this paper in a precise sense: the evaluation operator is undefined on the input because no terminating evaluation output exists. The string parses. It is valid content. But the operation it describes does not resolve into a judgment. It is not that the operation returns an unfamiliar or third kind of result. It returns no verdict. The evaluation does not complete. This is the same sense in which a function can be partial — defined on some inputs, undefined on others — and the inputs on which it is undefined are outside its domain, not inside its domain with a special output.

"Evaluation" is used throughout this paper in a correspondingly general sense: the minimal discrimination operation that makes "holds / fails to hold" meaningful at all. It is not a human cognitive act, and not a particular formal semantics. It is the condition under which any correctness-claim could in principle be settled. A formal system represents evaluation. An observer performs evaluation. Both are instances of the same operation at different configurations of consistency.

The criterion is general: an expression e is non-executable if any attempt to evaluate e requires presupposing a condition C that e denies, where C is a necessary condition of the evaluation being performed. "Necessary condition of the evaluation being performed" is precise: it means a condition without which this specific evaluation cannot occur, not a condition the expression happens to deny in some other context. "There are no evaluators in the next room" does not deny a condition necessary for the evaluation currently underway — the evaluator is here, not in the next room. "There are no evaluators anywhere" denies a condition necessary for the evaluation currently underway — someone is performing it. "Nothing exists" denies all conditions necessary for any evaluation. The criterion scales from local claims (evaluable) to self-undermining claims (non-executable) based on whether the denied condition is required for the evaluation itself to take place. "Nothing exists" denies the evaluative context (structure) required to perform evaluation. "This statement is false" denies the stability of the truth predicate required to complete evaluation. {P, ¬P} denies the consistency required for evaluation to resolve into a determinate output. In each case, the expression is syntactically well-formed — it passes the grammar — but the evaluation it requests cannot terminate because it negates a precondition of the evaluation process itself.

Formal logic avoids this by treating existence as a quantifier — a symbol inside a formula. ¬∃x: "there is no x." This is syntactically valid and semantically well-defined inside a structured framework. But that semantics cannot target "no structure whatsoever," because the semantics itself presupposes structure. The formula has an interpretation within a system that includes a domain, a satisfaction relation, and a valuation. These are something. The formula's interpretability is defined only relative to a semantics that is already structure; it cannot be used to certify coherence of "no structure whatsoever."

The model-theoretic retreat does not help. An empty domain — a model with no objects — is not nothing. It is a mathematical structure with a definition, properties, and a cardinality. The empty set is an object in set theory. A model of nothing is not nothing. It is a model. The distinction between "a universe with no objects in it" and "absolute nothing" is the distinction between a container and the absence of all containers. No formal system crosses that gap because formal systems are something.

The claim that nothing could "obtain" without anyone checking — that there could be a state of affairs in which nothing is the case and no evaluation is performed — still uses "state of affairs," "obtaining," and "being the case." These are structural concepts. They are something. There is no formulation of nothing that does not rely on the machinery of something to state it.

Nothing cannot be established, observed, verified, modeled, or represented, because each of those operations requires something to perform it. Nothing is not a state that fails to obtain. It is not a state.

## A Note on Operations and Objects

Formalization often reifies operations into symbols. This is useful — it enables derivation, system-building, and proof. But it can obscure the meta-level dependence of evaluation on conditions that are not themselves formalized.

Words like "exists," "true," and "false" are not elements inside a formal system. They are what the formal system is doing. "Exists" is the evaluative context — the meta-level condition under which any evaluation occurs at all. "True" is what evaluation returns when it succeeds. "False" is what evaluation returns when it fails. These are exit conditions. They sit outside the system in their unrestricted forms. Restricted versions — typed truth predicates, partial truth, hierarchical definitions — can be internalized under constraints, and these do real formal work. But the unrestricted operations, the ones the system ultimately relies on to assess its own outputs, remain external. Every internal truth predicate is defined relative to a metalanguage whose own correctness conditions are not internalized by that predicate. The internalization is always partial, always relative to a richer external framework that has not itself been internalized.

Formal logic assigned these operations symbols — ∃, T, F — placed the symbols inside formulas, and began manipulating them. The manipulation works at the notation level. You can derive things, build systems, prove theorems. But the symbols can be mistaken for the things they represent. The formalization is a representation of evaluation, not evaluation itself.

From this, a cascade of category errors becomes possible. Certain philosophical readings of formalism treat the existential quantifier as if "nothing exists" (¬∃x) can target absolute nothing rather than quantifying within a structure. "True" and "false" are treated as values in a set, which makes adding a third value ("both") look like a reasonable extension rather than a type error. The liar's paradox is treated as a deep result about truth rather than a string with no evaluable content.

This paper does not operate inside that cascade. It operates beneath it — at the level of the operations themselves.

## Consistency Is the Only Primitive

Consistency is a stable identity function. A thing remains itself. A is A.

In formal logic, "consistent" means no contradiction is derivable from a set of formulas. That is a downstream application of what this paper means. This paper uses consistency in the more primitive sense: a thing holds as what it is. The formal property — no contradiction derivable — is what consistency looks like when it operates at the level of sets of formulas. The primitive is prior to the formalization.

This cannot be derived from anything more basic because any derivation would use it. Any challenge to consistency presupposes consistency: the challenge must be the challenge and not something else for it to function as a challenge. The floor holds itself up. Every attempt to get beneath it routes back through it.

This is not an axiom chosen on faith. It is a boundary condition: whatever counts as questioning, reasoning, or explaining is already operating inside what it is trying to examine.

The distinction matters. An axiom is a starting point selected from alternatives. It could in principle be replaced by a different axiom, and the system built on it would change accordingly. A boundary condition is not selected. It is what is already operative before selection begins. Consistency could be stated as an axiom — "assume A is A" — and a formal system could be built on that assumption. But the act of assuming, the act of building, and the act of selecting the axiom all presuppose that each of those acts is itself and not something else. The axiom would be a formalization of something that was already in force before the formalization started. Treating it as an axiom understates it. An axiom can be rejected. Rejecting consistency presupposes consistency — the rejection must be the rejection and not something else. There is no position from which the rejection can be performed without using what it rejects. This is not an argument for consistency. It is the observation that arguments are already inside it.

Everything we observe — every object, pattern, process, entity, and observer — is a region of consistency that is consistent enough to cohere as a distinguishable pattern. Nothing holds these patterns together from outside. What we call a "thing" is a patch of consistency that has not stopped being consistent. It persists not because something sustains it but because persistence is what consistency looks like when there is enough of it to notice.

What we call identity, distinction, truth evaluation, and logic are not layers built on consistency. They are not a hierarchy of levels, each requiring the one before it. They are different combinations of state — what consistency produces at different configurations.

Identity — a thing is itself — is consistency at its simplest: a single patch. Distinction — A is not B — is what consistency produces when there are two patches, each coherent enough to persist and different enough from each other to not collapse into one. Truth evaluation — does this match that? — is what happens when patches interact. Logic — chaining evaluations — is consistency operating at scale.

There is an ordering here, but it is the ordering of accumulated state, not of separate dependent layers. A single patch is a precondition for two patches. Two patches are a precondition for interaction. Having two patches is having one patch plus more. The ordering is intrinsic to the accumulation of a single property, not a hierarchy of distinct things built on top of each other.

But what accumulates within this process is not bound to the evaluator's sequential walk. Accumulated state can contain references to any other region of accumulated state — jumps, self-calls, feedback loops. The evaluator walks forward. The content can point anywhere consistency permits. A sufficiently complex region of accumulated state can reach back and reorganize earlier state. This does not violate the evaluator's ordering. It uses the forward walk to execute a reordering of content. An observer re-evaluating its own premises — restructuring the order of things toward higher consistency — is this operation.

The observer is not external to this. Whatever is doing the noticing is itself a region of consistency — consistent enough to cohere as something that distinguishes, evaluates, and describes. Consistency all the way down, including the thing recognizing it.

This closes what might appear to be a gap in the argument. The paper establishes that consistency is a precondition of all thought, specification, and evaluation. A critic might object: that is an epistemological claim — a constraint on what can be known, thought, or evaluated. You have not established an ontological claim — a constraint on what can be or what exists. Perhaps reality can be inconsistent and we simply cannot think about the inconsistent parts. You have shown a limitation of the knower, not of the known.

The objection presupposes that epistemology and ontology are separate domains: thought is over here, looking at reality over there; thought has its constraints, and reality might not share them. This is a dualism. The framework rejects it. Thought is not a lens aimed at reality from outside. Thought is a region of consistency within reality. The observer is a patch of the same fabric as everything it observes. The knower is inside the known. There is no "over here" and "over there." There are configurations of consistency, some complex enough to evaluate other configurations.

If reality could be inconsistent somewhere, that somewhere would need to be a location — in a structure — distinguished from other locations — by identity and distinction — all of which are consistency operating. Any purported region of inconsistency that remains a region — re-identifiable, delimitable, describable — already satisfies the consistency conditions required to be a region. The only inconsistency that escapes that is not a special region but the collapse of regionhood itself, which is the same null target as absolute nothing. "Inconsistent reality" does not mean "reality with wild parts beyond our ken." It means no identity, no distinction, no structure, no location, no persistence. That is not a region of reality the evaluator cannot reach. It is the same "nothing" the paper already dissolves. "Reality without consistency" meets the non-executable criterion directly: the expression denies a condition (consistency) that the evaluation of the expression requires. Epistemology and ontology are not separate domains bridged by an inference. They are different descriptions of the same thing — consistency at different configurations. The gap between them is generated by assuming a dualism the framework shows to be incoherent.

True and false are evaluation outputs, not symbols that can be extended or combined. A system that assigns "both true and false" to a statement has not discovered a third truth value. It has committed a type error. Evaluation terminates one way or the other. A process that does not terminate has not produced a result. The set of evaluation outputs is {true, false}. A non-terminating process has not returned a member of that set. It has not returned at all. A computer that has not finished computing has not produced a third kind of answer. It has produced no answer. Treating non-termination as a truth value is like treating silence as a type of statement. Non-bivalent logics, supervaluations, and paraconsistent systems are formal notations that permit certain strings. That a notation permits something does not mean the thing it notates exists. These systems confuse syntactic permission with semantic reference.

This extends to the strongest version of the claim: dialetheism, the thesis that some contradictions are true. "True" is an evaluation exit-condition — what evaluation returns when it succeeds. A "true contradiction" would require evaluation to return both "succeeds" and "fails" for the same input. That is not a third evaluation output. It is the non-executability identified throughout this paper: a state that does not resolve. Truth-value gluts are not additional exits from the evaluation process. They are a notation for non-execution, mistaken for a result. A formal system can define symbols for gluts. The meta-level evaluation that certifies the system's behavior still terminates binarily: the system works as defined, or it does not. The glut notation has not extended evaluation. It has introduced bookkeeping whose correctness is certified by the same two-valued evaluation it purports to move beyond.

A statement that cannot be evaluated, such as "this statement is false," is not a paradox. It is an expression that does not execute. The string exists. It is valid content. But the operation it requests — evaluating a pointer that refers only to itself with no base case — does not terminate. There is no proposition to assess. This is not "evidence that a naive truth predicate cannot be globally defined." It is a string whose execution does not complete. The elaborate formal machinery built to handle it — Tarski hierarchies, Kripke fixed points, dialethic truth — is machinery designed to process an input that should have been rejected at validation. Tarski showed in 1933 that a sufficiently expressive language cannot contain its own global truth predicate without generating pathologies. This supports the structure described in this paper: evaluation and the assertions it evaluates occupy different levels, and collapsing them produces not depth but malfunction.

This is the same structure as "nothing." Both are expressible — consistency permits the string to exist as content. Neither is executable — the operation each describes requires the removal or completion of something the operation itself depends on. "This statement is false" needs the evaluator to confirm the evaluator's failure. "Nothing exists" needs structure to certify the absence of structure. The string is there. It just doesn't run.

Logic does not create the floor. It assumes the floor. Logic does not get to redefine what true and false mean, any more than a program gets to redefine what 0 and 1 mean at the hardware level. A formal system that redefines the outputs of evaluation has not gone deeper than evaluation. It has broken its own foundations from above.

## Dissolution

The question fails on both sides.

The "nothing" side. Nothing is expressible. The string exists. Consistency permits it as content. But "nothing" is not executable. It is an operation that targets the host container — the removal of all structure, including the evaluator processing the removal. The operation does not terminate. It is not that nothing is excluded from the space of possibilities by a rule. It is that the operation "nothing" describes cannot complete. Content can be deallocated. The evaluator cannot deallocate itself. Things end. Consistency does not.

The "why" side. "Why" demands justification. Justification is inference. Inference requires that distinctions hold. The demand for justification presupposes the floor. You cannot request a reason beneath the condition that makes reasons possible.

The question is not unanswered. It is expressible but not executable. It treats the precondition of explanation as if it were inside the space of explainable things. The question is a string the universe can contain but cannot run.

## Compact Argument

Consistency — a stable identity function, A is A — cannot be derived without presupposing itself. It is the boundary condition beneath which no explanation can reach. What we call identity, distinction, truth evaluation, and logic are not successive layers. They are different combinations of state: consistency as a single patch, consistency with two patches, patches interacting, and interaction at scale. Everything that persists — every object, process, observer, and pattern — is a region of consistency coherent enough to be distinguishable. The observer is not external to this. It is a region of consistency within the thing it observes. Thought and reality are not separate domains requiring a bridge from one to the other. They are configurations of the same thing. The apparent gap between "thought requires consistency" and "reality requires consistency" is generated by a dualism the framework rejects.

"Absolute nothing" — the absence of all structure — is expressible. The string exists. But it is not executable. It describes an operation — the removal of all structure including the evaluator — that does not terminate. Specifying it requires structure (distinction, modality, state-of-affairs talk). Modeling it requires structure (a domain, a satisfaction relation). Evaluating it requires structure (an evaluation context). Every tool that could certify its coherence is made of the thing it negates. Content can be deallocated. The evaluator cannot deallocate itself.

"Why is there something rather than nothing?" is expressible but not executable. Both the "nothing" side (an operation that cannot complete) and the "why" side (demands justification beneath the condition that makes justification possible) presuppose the floor they are trying to question. The question is a string the universe can contain but cannot run.

## Objections and Replies

### "You have only shown that nothing cannot be represented, not that nothing cannot be."

This paper concedes the point. Nothing can be represented. The string exists. It is expressible. Consistency permits it as content. The claim is not that nothing cannot be represented but that nothing cannot execute — the operation the string describes does not terminate, because completing it requires the removal of the structure performing the operation.

The remaining form of the objection is: there is a gap between what can execute and what can be, and absolute nothing might sit on the far side of that gap. This reduces to one claim: there are states of affairs that no process could ever instantiate, verify, or reach, and these are still genuine possibilities.

The objection asks for a bridge principle — a stated rule connecting representability to possibility — and then positions itself as the neutral default that needs no such principle.

But the objection is not neutral. It carries its own bridge principle, unstated: modal space is larger than representational space. It asserts that there are genuine possibilities which cannot in principle be specified, represented, modeled, or evaluated by any structure — and that these are still real possibilities. This is a positive metaphysical commitment. It requires defense. It does not get to operate as the unmarked default simply because it is the more familiar position.

Compare the two principles directly.

This paper's principle: a possibility must be specifiable — not by us, not by any particular formal system, but in principle, by something. A "possibility" that cannot be specified even in principle by any operation is not a possibility. It is the word "possible" doing no work.

The objector's principle: there exist possibilities that cannot be specified even in principle by anything. They are real but permanently beyond the reach of all structure.

If "possible" has no criterion of application even in principle, it is indistinguishable from noise.

The first is a constraint on what it means to call something a possibility: if there is no way, even in principle, to draw a distinction that picks it out, then the term "possible" has no operational content when applied to it. The second is a blank check: it allows "possible" to be applied to things that no operation could ever distinguish, specify, or evaluate. A term that applies to the in-principle-undistinguishable has no meaning. That is not a restriction imposed by this paper. It is a consequence of what words do.

This is not a claim about falsifiability in the Popperian sense. It is a claim about meaning. The objector must answer a content question: what does "possible" mean for something that cannot in principle be represented, specified, evaluated, or modeled by anything? If "possible" means "obtains in some possible world," who specifies the possible world? If it means "not ruled out by logic," whose logic, running where? If it means "conceivable," conceivable by what? Every attempt to give content to "absolute nothing is possible" requires structure — the very thing whose absence is being called possible. The word "possible" in this context is a check that cannot be cashed.

The objector's position also has a consequence the objector will not accept. If possibility exceeds specifiability — if things that no operation could ever specify are still genuinely possible — then this applies not only to absolute nothing but to every unspecifiable "state." Square circles. Married bachelors. Colorless green ideas that sleep furiously. The objector will say these are logically impossible, not merely unspecifiable. But who determines logical impossibility? An evaluator. Using consistency, identity, and distinction — the evaluation floor. The objector is using the floor to partition their unspecifiable possibilities into "genuinely possible" and "logically impossible." They are applying a specifiability criterion — certain candidates must be evaluable as logically impossible, which requires the evaluative machinery to reach them — while claiming not to need one. The blank check has been quietly limited by the very apparatus the objector claims to have dispensed with.

### "Possibility is always theory-relative; your specifiability constraint is not a general metaphysical rule."

A sophisticated version of the objection avoids claiming that unspecifiable possibilities exist. Instead it says: "possible" is always relativized to a background theory or semantics. Within any such theory, absolute nothing is not a candidate state. So the original question is ill-posed or ambiguous. But this does not concede a general metaphysical rule connecting specifiability to possibility — it only says the traditional tools never meant to talk about "no structure whatsoever."

This is a retreat, not a rebuttal. It concedes the object-level point — absolute nothing is not a candidate within any theory — and refuses only the meta-level principle. But the refusal is empty. The critic agrees that absolute nothing fails to be a candidate in every theory. This paper provides the structural reason why: specifying it requires the machinery it negates. The critic wants to note this failure without explaining it. The paper explains it. If the critic agrees that absolute nothing is not a candidate in any modal framework, and the paper provides the structural feature that excludes it from every such framework, the critic is not disagreeing. They are agreeing while declining to say so.

The question "why is there something rather than nothing?" is not asked within a theory. It is asked at the level where theories bottom out. Theory-relative modality does not reach this level. If "possible" is always theory-relative, then the question — which asks about the possibility of there being no theories, no structures, no frameworks at all — cannot be posed within any theory's modal space. It is either expressible but not executable (which is this paper's claim) or it requires a notion of possibility that is not theory-relative (which returns the critic to the position this paper already addresses).

### "Models are not supposed to be the thing; they show coherence of a description."

Granted. Models demonstrate that a description is internally consistent by providing a structure that satisfies it. The objection is that it does not matter that the model itself is something, because the model is not claiming to be the described state of affairs — only to show that the description does not contradict itself.

But consider what this test requires when the description is "no structure exists." A model demonstrates coherence by providing a structure that satisfies the description. When the description is "no structure," no model can satisfy it without contradicting it. An empty domain is not a model of no structure. It is a mathematical object — with a definition, properties, and a cardinality of zero — that lives inside set theory. The coherence it demonstrates is the coherence of set theory containing the empty set, not the coherence of there being nothing at all. The gap between "a universe with no objects in it" and "absolute nothing" is precisely the gap between a container and the absence of all containers. The model-theoretic framework cannot cross this gap because it is on one side of it.

This is not a limitation of any particular model. It is a structural feature of what models are. Models are structures. The description "no structure" cannot be modeled by a structure without the model contradicting the description. The tool cannot perform this particular job.

### "¬∃x has semantics; it is not 'semantically inapplicable' just because it presupposes structure."

Within a formal system, ¬∃x has a precise interpretation: no assignment and no domain element satisfies the formula. In standard first-order logic, it is false if empty domains are disallowed, or true in free logics that permit them. In either case, the formula has well-defined behavior within the formalism.

This paper does not deny that the formula has formal semantics. The claim is that the formal semantics does not extend to the referent the formula would need in order to describe absolute nothing. The formula's semantics consists of a domain, a satisfaction relation, an interpretation function, and a valuation. These are structural machinery. The semantics itself is something. A formula that has semantics — that is interpretable within a system of structural machinery — cannot, by having that semantics, demonstrate the coherence of there being no structural machinery. The formula's interpretability is the problem, not the defense. Pointing out that the formula is meaningful inside a structural framework is a demonstration of exactly what this paper argues: you cannot touch nothing without using something.

### "Non-bivalent and paraconsistent logics come with rigorous semantics; dismissing them as 'syntactic permission' is not a critique."

These logics are coherent formalisms. They come with consequence relations, algebraic valuations, and carefully defined model-theoretic structures. Their internal rigor is not in question.

The claim of this paper is narrower and conditional: these systems do not change the preconditions of evaluation that this paper identifies — consistency as the substrate from which identity, distinction, and truth evaluation are observed. They change the bookkeeping inside a formalism. A paraconsistent logic defines a consequence relation in which explosion fails. To define that relation, the logic must use identity, distinction, and truth evaluation — combinations of the same consistency this paper identifies as the floor. The metalanguage in which the paraconsistent semantics is stated is classical. The definitions of the non-standard truth values are given in a framework that presupposes standard truth values. The system does not escape bivalence at the meta-level. It introduces non-bivalent notation at the object level while relying on bivalent evaluation to certify that the notation behaves as intended.

This means two things. First, these formalisms do not help with absolute nothing, because they operate within structure and presuppose the consistency they would need to dissolve. Second, these formalisms do not demonstrate what their strongest philosophical proponents claim: that evaluation itself can tolerate contradiction. Object-level non-explosion does not establish that evaluation has been extended. It establishes a notational choice certified by the same bivalent evaluation it claims to surpass. The question of whether these programs have any legitimate use case at all — even within their own domain — is addressed separately in Passarelli (2026), which argues they do not.

### "The liar is well-formed in a language with a truth predicate; banning it is a policy choice, not a forced result."

Every validation rule is a policy choice. Including the choice to admit unrestricted self-referential truth predicates into the object language. The question is which policy choice is better justified.

Tarski demonstrated in 1933 that a formally consistent language cannot contain its own unrestricted truth predicate. A language that admits "this statement is false" as well-formed has not discovered a deep property of truth. It has adopted a language specification that Tarski proved generates pathologies. Subsequent work — Kripke's fixed-point theory, revision theories, dialethism — builds elaborate machinery to handle these pathologies. The alternative, adopted here, is to recognize that the string is expressible — it exists as content — but not executable: it has no base case, no terminating referent, and the operation it requests does not complete. The string is syntactically well-formed. The claim is that it fails a precondition of execution: the input must have content that terminates.

This is not ad hoc. It follows directly from what consistency requires: truth evaluation is a process that requires a proposition, and a proposition must have content that terminates. A self-referential loop with no ground does not meet this requirement. Rejecting it is not more of a policy choice than rejecting a division by zero. The operation is not defined for that input.

### "Your 'pending' behaves like a third status; your claim that evaluation must terminate yes/no is a stipulation."

If evaluation can be pending, and pending is neither true nor false, then the paper appears to admit a third status while insisting there are only two. The critic argues this is the paper's own version of the move it rejects in non-bivalent logics.

Pending is not a status of the evaluation. It is a non-return. The set of evaluation outputs is {true, false}. A function that has not returned has not returned a third member of that set. It has not returned. The distinction is between outputs and non-outputs, not between three kinds of output. A process that loops forever does not produce a result that is "neither true nor false." It produces no result. Confusing "no output" with "a third output" is a category error — the same category error this paper identifies throughout: treating the lack of a thing as a special kind of the thing.

The requirement that evaluation terminates in one of two outcomes is not a stipulation about how formal systems must behave. Formal systems can define whatever return types they like. The claim is that the operations — the actual evaluation that a system performs when assessing whether a proposition holds — terminate binarily. A formal system that defines a three-valued return type has not extended evaluation. It has defined a notation with three symbols. Whether those symbols correspond to genuine evaluation outcomes is the question, and the answer is not settled by the notation existing.

### "Dialetheism says some contradictions are true. Your framework just assumes otherwise."

This paper rejects dialetheism on explicit grounds. "True" is an evaluation exit-condition — what evaluation returns when it succeeds. A "true contradiction" would require evaluation to return both "succeeds" and "fails" for the same input. That is not a third evaluation output. It is the non-executability identified throughout this paper: a state that does not resolve into a judgment. Truth-value gluts are not additional exits from the evaluation process. They are a notation for non-execution, mistaken for a result.

This is not an assumption. It is a consequence of what evaluation is. The meta-level process that certifies any dialetheic system — defining its truth values, proving its properties, verifying its behavior — is itself bivalent. The meta-level definitions either hold or they do not. The meta-level proofs are either valid or they are not. There is no contradiction-tolerance at the meta-level. Dialetheism introduces contradiction-shaped strings at the object level while relying on a contradiction-intolerant meta-level to certify that those strings behave as intended. The demonstration undermines the thesis at the level the thesis claims to operate.

### "You overstate what logic 'cannot' do — typed truth predicates, partial truth, and restricted self-reference do real work."

They do. This paper does not deny that restricted truth predicates, typed hierarchies, and partial truth definitions are productive formal tools. They are. The claim is narrower: the unrestricted operations that these tools partially internalize remain external. Every internal truth predicate is defined relative to a metalanguage whose own correctness conditions are not internalized by that predicate. The internalization is always partial. The external evaluation is always presupposed. These programs succeed precisely because they accept the constraint this paper describes — that full truth, full existence, full evaluation sit outside the systems that use them — and work within it rather than against it. They are evidence for the paper's claim, not against it.

### "Your 'narrower claim' is defensible, but it is not what you are arguing."

It is exactly what this paper argues. The claim has never been that "nothing exists" produces a proof-theoretic contradiction in the narrow sense — that from it one can derive both P and ¬P within a formal system. The claim is that absolute nothing is expressible but not executable: it can be stated, represented, and written as content, but the operation it describes — the removal of all structure including the evaluator — does not terminate. It is not a state that is excluded from the space of possibilities by some rule. It is an operation that does not complete, because completing it requires the thing it removes.

This is not a weaker claim offered as a fallback. It is the thesis.

## Author

Tom Passarelli

## License

CC0. This work is in the public domain.
